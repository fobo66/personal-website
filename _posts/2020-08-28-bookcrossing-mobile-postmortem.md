---
title: "Bookcrossing Mobile: post mortem"
published: true 
---

Hello! Recently I received copyright infringement notice about my favorite pet project, Bookcrossing Mobile app, and was asked to remove the app from Play Store. On this sad note, I decided to discontinue its development completely and keep its code open and untouched. In this article, I will describe my journey with development of this project, some cool tricks I've learned, as well as provide some description of the project for anyone who may be interested in it. Project will rot quickly and will become mostly unusable after a short period of time (but still may serve as a reference), but my experience working on it might be useful for those who are looking to start some mobile app project alone.

## Backstory

I've started this project to explore RxJava and Firebase, also to build up my portfolio and to learn. Idea came to my mind when I was browsing Play Store in search of the app to exchange books. I've been participating in bookcrossing movement since 2010, when the first shelf appeared in my hometown. It was not systemized, and a lot of books were not registered on the website, mostly because at that time site was quite inconvenient to use, and, if I'm remembering correctly, site was only available in English. So, after not finding the official Bookcrossing app on the Play Store, I decided to create my own app for bookcrossing that will make it easy to release new books and that is convenient to use.

I've created a list of desired features, but there was almost immediately appeared one more problem: main bookcrossing website didn't have any API available. So I had two options: HTML parsing on client to extract some data or go with my own backend.

I've tried to go with Google services, and started researching Google Cloud Platform stuff for backend. GCP is cool, and it offers a lot of really good services, but it all required a lot of effort to invest, and that wasn't what I wanted. Ideally, I would have preferred to spend as little time on backend development as possible, so I can focus mostly on app side.

Thus, I turned my look to Firebase. It was at that time recently acquired by Google, and there was not so much services they offered. But it was quite enough for my needs: Realtime Database was quite enough to store basic data that I had, Cloud Storage fitted perfectly for storing cover images, and Authentication worked just fine for handling users. Plus later I've added Ads and Analytics as a side effect. There was even convenient FirebaseUI wrapper that helped with binding Firebase services with UI.

I had an eye on RxJava for a long time, it seemed for me the good choice for the most Android apps due to its good threading abstractions, concise API and functional programming fleur. Reactive programming didn't seemed too complex for this project for me, and I wanted to improve my knowledge of Rx, so I decided to build my app in Rx-way.

These factors shaped the initial architecture of the app and helped decide how it will look like.

## Initial development

Once I figured out what to do, I chose then-popular MVP architectural pattern for my new app that was implemented with help of Moxy library. It was quite straightforward, given the amount of code on StackOverflow ready for copying and pasting right into the project. For non-trivial issues I've picked some libraries from Github with decent amount of stars. I followed examples for Firebase setup and for Moxy, without quite thinking about fitting it into the MVP pattern, so I ended up with a lot of Firebase-related code in views and a lot of business logic in presenters, all mixed up. I even tried to write some tests, but it looked for me like there was not so much to test in terms of business logic, so I haven't added any tests. To be frank, it wasn't quite possible to add tests in that situation, because of a coupling business logic with UI, as well as lack of support for tests on Firebase side.

## Release

After I've implemented most of my ideas, I decided to prepare the app for release, but perform some manual testing of the whole app beforehand. I did test each feature in isolation while developing, but now I was checking everything in combination, each user flow I can come up with. There were some annoying issues with styles for toolbar, but nothing critical. I've spent quite a lot of time (couple of days, actually) trying to fix toolbar appearance, but nothing worked. So, out of frustration and poor health I've postponed release for later.

After few months I got back to releasing process and decided to let that pesky toolbar bug into this release. _Spoiler: I've fixed it only three years later with help of Insets._ Also, the other bugs that were here I decided to fix after release, since I considered them minor.

App went live on beta track at some date, and after that I've noticed quite a few crash reports in Crashlytics. I've fixed them immediately.

Mostly app was functional, but first users have uncovered scenarios I wasn't prepared for. For example, some unusual user navigation flows were leading to crash because of uninitialized variable. It took me the whole day to fix.

Another interesting issue was with ads config. I've sourced Firebase Ads integration code from multiple places, and it was complete mess, TBH. Even more, it didn't work on release build because of misconfiguration. It took me 2 days to figure out what was wrong and configure it properly.

I haven't promoted the app anywhere and I haven't bought installs. Not because I'm against it, just didn't wanted to bother with marketing stuff and pay for advertisements, more wanted to focus on improving quality.

## Big refactoring

Time passed, I was slowly improving some features and fixing bugs so I would be able to release to the main track, not beta. And then suddenly Google announced their Jetpack project with migration to AndroidX libraries and many more. I was excited by the new approach Google has taken and wanted to integrate it as soon as possible. But there was a catch: when I started to migrate app to AndroidX, I've noticed that some libraries I've used started breaking the build with AndroidX, even with Jetifier enabled. After digging into the source code I've found that these libraries were using some components of old support libraries that were not migrated to the AndroidX or were removed or renamed. I've also noticed that some important libraries were abandoned by their maintainers. I was unable to migrate them myself because of poor code style of these libraries, as well as the general complexity of the solutions. For example, RxPermissions library used some weird hacks with ActivityCallbacks to provide the ability to request permissions in Rx chain, and I failed to understand what was going on there. And the funniest thing with this library was that actual crutch that broke Jetifier was placed in instrumented tests for this library. Another interesting example was with Moxy library for easier building of MVP pattern classes. Issues with AndroidX here were easy to fix, but it turned out that original developers were unable to maintain this library due to lack of time. It was forked by multiple people later on, and even turned into community-driven project (it started as in-house project inside one software development studio, but apparently the company has little interest in maintenance of the project after maintainer gave up). But it was much later than I've initially started migration.

This all was very frustrating. Amount of work required was immense: I needed to abstract out unmigrated dependencies to replace them, unbind Firebase logic from UI to ease migration and find replacement for non-AndroidX dependencies. All this work took more than a year with breaks, and at this time I was able to update some dependencies with their AndroidX variants. As a side effect, I decided to fix architectural inconsistencies as well and move everything to the one architectural pattern: I've managed to extract Firebase related code to the proper model layer via data sources and repositories, and this helped me to extract logic from presenter to the usecase, reducing presenter size dramatically. Previously I was unable to decouple this logic properly because of composition with UI and poor Dagger setup, but with all this fixed, this presenter started to shine like a freshly painted car. It was quite satisfying to look into git diff for merge commit after I've finished this migration.

I feel like I need to explain what "poor Dagger setup" means. I had some class like `ApiContainer` (I don't remember exact name) where I was injecting Firebase classes in fields, and this class was injected in BasePresenter as `dagger.Lazy`. This sophisticated optimization coupled each presenter to the base, even if it didn't need any of the Firebase classes, because for some mysterious reason I didn't know about constructor injection. I've started to inject required classes directly in the presenter where they were needed, inlining some base class methods and refactoring some logic. This allowed me to remove `BasePresenter` completely, as well as `ApiContainer`, and that alone simplified all my presenters dramatically and allowed me to see where I can do further improvements.

## State after refactoring

After post-refactoring release was live, I had some time thinking what I can do next. There were quite a lot of things that bugged me, and I wanted to improve them. I decided to create Github Project to sort them out, as well as to test this feature. We didn't use Github at work, so I was curious to learn how it works and is it any useful for project management.

Over the years, a lack of tests became the most pain in the bum. You can definitely live happily without any test in your project, they say, but in practice I learned that the presence of tests indicates good health of the project and allows you to iterate faster, despite it takes more time to write tests initially. It was discussed many times over the years in the industry, but for me tests are the must have in any project.

At that stage, most of the logic wasn't testable due to binding of some Firebase related classes to UI just for loading a cover image from Cloud Storage. Untangling it required a few weeks of work, mostly to extract logic to appropriate layers. I chose Fernando Cejas' clean architecture approach with use cases, repositories and datasources. It looked like an over-complication at first, but I decided to keep retrieval logic in the datasources, and put parsing and mapping in the repositories that depend on those datasources. And logic resided in the usecases named after specific action user needed to perform, like add books to "stash" (favorites list) or claim book via scanning its QR code. All these layers were covered with exhaustive tests. In the end I've got a fine looking presenters with nicely composed Rx chains that I was finally able to cover with tests, but realised that there was no need to cover presenters since logic was already tested, and presenters were only acting as the holders of usecases and Rx subscriptions. Also I ditched an old RxJava adapter library for Firebase, because it was full of Java static methods and it wasn't completely thread-safe, so I rewrote adapter functions inside my datasources. Basically, wrapping Firebase stuff returned as `Task` into Rx Observables turned out to be the main function of the datasources. As a side effect of this, some of the repos ended up being quite anemic, i.e. just proxying datasource methods. It's not ideal, but the benefits of this approach overall outweigh this drawback, so I'm fine with that.

As the next step, I decided to reimplement book position selection. Initially, I was resolving book position inside the special Cloud Function by the position's name provided by the user and user's city. After some time in production I found out that it doesn't work most of the time, because users tend to write descriptions of the places that are not easily searchable on the map, i.e. not the names of the places, like "Stan's Coffee shop", but something more descriptive about the place, like "At my apartments" or "Shelf near the entrance to the library". In addition, there were some weird crashes inside Promises of the Google Maps JS SDK. I initially wanted to add location picker, but it seemed too complex, thus I ended up implementing this weird automatic resolver. Though it was fun to work with Cloud Functions when they were just released, I figured that this solution was too restrictive, so I decided to remove this broken automation and implement proper location picker.

Well, to pick location on the map, first of all you need a map. As a map provider, I chose Mapbox: it seemed to be great alternative to the Google Maps that is more detailed and is convenient to use. I even planned to use it across the whole app, e.g. to show books on the map and show location of the particular book inside some small static map in book screen. Unfortunately, it didn't happen, and the whole Mapbox integration lead to a lot of frustration.

I've added Mapbox quickly, since its API was quite similar to Google Maps. In basic shape it worked fine, but issues started to arise when I started to add logic for the main feature – selecting position. Various random bugs started to appear on the map that eventually turned to crashes in native code. There was an open issue on Github for that, but it was quickly closed with a recommendation to use newer version. Unfortunately, newer version contained the same bug.

Another frustrating issue was in the documentation for Mapbox. Information appeared to be scattered across different pages, and it took me quite a lot of time to gather all the pieces together to understand what's going on here at all. For example, it was quite challenging to find the description of the GeoJSON format they're using. For some reason, it didn't googled well, and there was little mention of it in docs. As far as I understood, they've used a lot of terminology from GeoJSON standard, without quite referencing definition of this terminology back to the standard in their docs. Plus, SDK was not quite covered with javadoc comments.

I've spent week or two trying to solve it until "Screw it!" moment. I decided not to bother with Mapbox any longer and rewrote all the code to Google Maps in a couple of hours. It even fit more nicely with Rx due to slightly more open interface, although it's only my humble opinion. Since Maps SDK was not quite designed with regard to Rx, it required me to use regular hack with `PublishSubject` to get it working, and Google Maps SDK had all the necessary callbacks I needed for my business logic. Mapbox SDK required some data processing and was less asynchronous in this case. <!-- Need to actually fact-check this statement, since I don't quite remember after all this time -->

## Buried plans

Before I received DMCA takedown request, I was working on integrating analytics. At work, we use analytics extensively for each app feature, and it really helps to see which part is actually useful for our customers. It inspired me to integrate analytics further. I wasn't aware about the privacy downsides of Google Analytics back then, so I decided to use it first, keeping space for other analytics providers just for the sake of doing it. I wanted to have analytics layer decoupled from the particular analytics provider, so I was planning to have core analytics module with interfaces, and module for each provider, and register provider inside app's Dagger module. Also, analytics module should have been used only in usecases, because I wanted to track how often each feature is used, not the user input. Screen tracking would also be useful, but some providers required Activity for it to be around.

While I was studying different analytics providers, I found out that they all have different features and different API that were not quite compatible. It was hard to find good interface for major analytics providers, and most importantly, they often required Context or Activity instance to be around, which wasn't fitting to my app's architecture and desired structure of the analytics module. I was trying to get some time and effort to handle this, but it was too late.

As another planned big thing I wanted to migrate to Jetpack ViewModel. Given the amount of views and presenters in the project, it didn't seem as much work at the first glance, but actually it meant replacing the whole architectural pattern, which potentially can take a lot of effort. After refactoring I had clearly separated layers, but the main problem was that Rx subscriptions were stored both in presenters and in views, and that wasn't supposed to happen with ViewModels. As far as I understood, in ViewModels it was only possible to subscribe to stuff in views (with little help from AutoDispose to make subscriptions lifecycle-aware). Main reason of this was to avoid situation with Moxy: when it became abandoned, it blocked migration to AndroidX, and the whole confusion with multiple forks that followed didn't make things easier. And despite it's not clear whether Google will stick to their proposed ViewModel and MVVM architecture or create something completely different, at least it would be safer to expect them to provide some migration mechanism, or at least generous deprecation policy, as they do with SDK. In that case any change in architecture forced from outside will be easier. But we can't know the future, we can only be flexible to adjust to it.

## Conclusion
